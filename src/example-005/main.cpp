#include <stdlib.h>

#define HAVE_REMOTE
#include <pcap.h>

/* 4 字节的 IP 地址 */
typedef struct ip_address {
    u_char byte1;
    u_char byte2;
    u_char byte3;
    u_char byte4;
} ip_address;

/* IPv4 首部 */
typedef struct ip_header {
    u_char ver_ihl;         // 版本 (4 bits) + 首部长度 (4 bits);
    u_char tos;             // 服务类型 (Type of services)
    u_short tlen;           // 总长 (Total length)
    u_short identification; // 标识 (Identification)
    u_short flags_fo;       // 标志位 (Flags) (3 bits) +
    // 段偏移量 (Fragment offset) (13bits)
    u_char ttl;             // 存活时间 (Time to live)
    u_char proto;           // 协议 (Protocol)
    u_short crc;            // 首部检验和 (Header checksum)
    ip_address saddr;       // 源地址 (Source address)
    ip_address daddr;       // 目的地址 (Destination address)
    u_int op_pad;           // 选项与填充 (Option + Padding)
} ip_header;

/* UDP 首部 */
typedef struct udp_header {
    u_short sport;          // 源端口 (Source port)
    u_short dport;          // 目的端口 (Destination port)
    u_short len;            // UDP 数据包长度 (Datagram length)
    u_short crc;            // 检验和 (Checksum)
} udp_header;

/* 回调函数原型 */
void packet_handler(u_char* param, const struct pcap_pkthdr* header,
                    const u_char* pkt_data);

int main(void)
{
    pcap_if_t* alldevs;
    pcap_if_t* d;
    int inum;
    int i = 0;
    pcap_t* adhandle;
    char errbuf[PCAP_ERRBUF_SIZE];
    u_int netmask;
    char packet_filter[] = "ip and udp";
    struct bpf_program fcode;

    /* 获取设备列表 */
    if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1) {
        fprintf(stderr, "Error in pcap_findalldevs: %s.\n", errbuf);
        exit(1);
    }

    /* 打印列表 */
    for (d = alldevs; d != NULL; d = d->next) {
        printf("%d.%s", ++i, d->name);

        if (d->description) {
            printf(" (%s)\n", d->description);
        } else {
            printf(" (No description available)\n");
        }
    }

    if (i == 0) {
        printf("\nNo interfaces found! Make sure WinPcap installed.\n");
        return -1;
    }

    printf("Enter the interface number (1-%d):", i);
    scanf("%d", &inum);

    if (inum < 1 || inum > i) {
        printf("\nInterface number out of range.\n");
        /* 释放设备列表 */
        pcap_freealldevs(alldevs);
        return -1;
    }

    /* 跳转到已选设备 */
    for (d = alldevs, i = 0; i < inum - 1; d = d->next, i++);

    /* 打开适配器 */
    if ((adhandle = pcap_open(d->name, 65535,
                              PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf)) == NULL) {
        fprintf(stderr, "\nUnable to open the adapter."
                "%s is not supported by WinPcap.", d->name);
        /* 释放设备列表 */
        pcap_freealldevs(alldevs);
        return -1;
    }

    /* 检查数据链路层，为了简餐，我们只考虑以太网 */
    if (pcap_datalink(adhandle) != DLT_EN10MB) {
        fprintf(stderr, "\nThis program works only on Ethernet networks.\n");
        /* 释放设备列表 */
        pcap_freealldevs(alldevs);
        return -1;
    }

    if (d->addresses != NULL) {
        /* 获取接口第一个地址的掩码 */
        netmask = ((struct sockaddr_in*)
                   (d->addresses->netmask))->sin_addr.s_addr;
    } else {
        /* 如果接口没有地址，那么我们假设一个 C 类的掩码 */
        netmask = 0xffffff;
    }

    // 编辑过滤器
    if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) < 0) {
        fprintf(stderr, "\nUnable to compile the packet filter."
                "Check the syntex.\n");
        /* 释放设备列表 */
        pcap_freealldevs(alldevs);
        return -1;
    }

    printf("\nListening on %s...\n", d->description);
    /* 释放设备列表 */
    pcap_freealldevs(alldevs);
    /* 开始捕捉 */
    pcap_loop(adhandle, 0, packet_handler, NULL);
    return 0;
}

/* 回调函数，当收到每一个数据包时会被 WinPcap 调用。*/
void packet_handler(u_char* param, const pcap_pkthdr* header,
                    const u_char* pkt_data)
{
    struct tm* ltime;
    char timestr[16];
    ip_header* ih;
    udp_header* uh;
    u_int ip_len;
    u_short sport, dport;
    time_t local_tv_sec;
    /* 将时间戳转换成可识别的格式 */
    local_tv_sec = header->ts.tv_sec;
    ltime = localtime(&local_tv_sec);
    strftime(timestr, sizeof timestr, "%H:%M:%S", ltime);
    /* 打印数据包的时间戳和长度 */
    printf("%s.%.6ld len:%d ", timestr, header->ts.tv_usec, header->len);
    /* 获得 IP 数据包头部的位置 */
    ih = (ip_header*)(pkt_data + 14);  // 14：以太网头部长度
    /* 获得 UDP 数据包头部位置 */
    ip_len = (ih->ver_ihl & 0xf) * 4;
    uh = (udp_header*)((u_char*)ih + ip_len);
    /* 将网络字节序列转换成主机字节序列 */
    sport = ntohs(uh->sport);
    dport = ntohs(uh->dport);
    /* 打印 IP 地址和 UDP 端口 */
    printf("%d.%d.%d.%d : %d -> %d.%d.%d.%d. : %d\n",
           ih->saddr.byte1, ih->saddr.byte2,
           ih->saddr.byte3, ih->saddr.byte4, sport,
           ih->daddr.byte1, ih->daddr.byte2,
           ih->daddr.byte3, ih->daddr.byte4, dport);
}